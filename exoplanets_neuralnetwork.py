# -*- coding: utf-8 -*-
"""exoplanets_neuralnetwork.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KdJ8sBgkHnb7iS4bytcz5me52mKpVwtO
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
from matplotlib import pyplot as plt
import numpy as np

# each poiunt is planetary radius, orbital period, planet type (gas giant or terrestrial)

data = [
    [0.273949, 0.021, 1],
    [0.359459, 0.02, 1],
    [5.21292,	1.336, 0],
    [5.12604,	2.627, 0],
    [0.39588, 0.04, 1],
    [0.39588, 0.023, 1],
    [0.380045, 0.016, 1],
    [5.0826,	0.588, 0],
    [5.21292,	4.53, 0],
    [5.38668,	2.982, 0],
    [0.391921, 0.008, 1],
    [0.284242, 0.003, 1],
    [0.29691, 0.04, 1],
    [5.43013,	2.707, 0],
    [0.32383, 0.079, 1],
    [0.273157, 0.047, 1],
    [0.253363, 0.002, 1],
    [5.25636,	0.633, 0],
    [3.91403,	0.85, 0],
    [0.645284, 0.128, 1],
    [0.288992, 0.01, 1],
    [5.38668,	2.285, 0],
    [0.39588, 0.004, 1],
    [4.3441,	1.098, 0],
    [0.34402, 0.021, 1],
    [5.34324,	4.937, 0],
    [5.12604,	2.24, 0],
    [0.340457, 0.006, 1],
    [5.12604,	4.377, 0],
    [0.352333, 0.005, 1],
    [0.39588, 0.078, 1],
    [5.21292,	4.06, 0],
    [4.77851,	3.351, 0],
    [5.03916,	4.791, 0],
    [0.32858, 0.016, 1],
    [0.279095, 0.078, 1],
    [5.16948,	0.611, 0],
    [4.60475,	2.464, 0],
    [0.376086, 0.031, 1],
    [0.391921, 0.032, 1],
    [5.51701,	2.037, 0],
    [4.82195,	4.716, 0],
    [0.300869, 0.008, 1],
    [0.243466, 0.011, 1],
    [4.64819,	0.414, 0],
    [5.0826,	1.337, 0],
    [0.352333, 0.019, 1],
    [0.344416, 0.012, 1],
    [4.69163,	3.796, 0],
    [5.25636,	3.079, 0],
    [0.391921, 0.032, 1],
    [5.43013,	3.656, 0],
    [4.90883,	4.179, 0],
    [0.376086, 0.033, 1],
    [0.387962, 0.024, 1],
    [5.38668,	3.926, 0],
    [0.316704, 0.008, 1],
    [4.69163,	3.26, 0],
    [4.99572,	1.858, 0],
    [0.324622, 0.062, 1],
    [0.376086, 0.24, 1],
    [4.82195,	2.376, 0],
    [5.47357,	0.035, 0],
    [0.316704, 0.061, 1],
    [0.241487, 0.007, 1],
    [4.90883,	2.693, 0],
    [5.0826,	1.814, 0],
    [5.21292,	3.808, 0],
    [0.316704, 0.055, 1],
    [5.34324,	1.532, 0],
    [5.34324,	1.375, 0],
    [0.313537, 0.033, 1],
    [0.255343, 0.043, 1],
    [5.38668,	0.683, 0],
    [5.56045,	2.838, 0],
    [0.324622, 0.023, 1],
    [4.90883,	4.819, 0],
    [3.24504,	1.259, 0],
    [0.344416, 0.016, 1],
    [5.34324,	2.689, 0],
    [0.372127, 0.061, 1],
    [0.352333, 0.008, 1],
    [0.36421, 0.041, 1],
    [0.712584, 0.103, 1],
    [3.32758,	0.258, 0],
    [4.95227,	4.337, 0],
    [0.312745, 0.019, 1],
    [0.312745, 0.042, 1],
    [0.340457, 0.01, 1],
    [0.292951, 0.058, 1],
    [4.86539,	4.285, 0],
    [5.34324,	4.152, 0],
    [0.384004, 0.148, 1],
    [5.16948,	2.844, 0],
    [4.77851,	4.463, 0],
    [0.288992, 0.034, 1],
    [4.86539,	1.995, 0],
    [0.384004, 0.056, 1],
    [5.38668,	0.304, 0],
    [5.16948,	4.528, 0],
]

mystery_planet = [5.25636, 2.582]

# scatter plot them

def vis_data():
  plt.grid()

  for i in range(len(data)):
    c = 'b'
    if data[i][2] == 0:
      c = 'r'
    plt.scatter([data[i][0]], [data[i][1]], c=c)

  plt.scatter([mystery_planet[0]], [mystery_planet[1]], c='gray')

vis_data()

# network diagram

#      o    planet type
#     / \   w1, w2, b
#    o   o  planetary radius, orbital period

# defining sigmoid function

def sigmoid(x):
  return 1/(1 + np.exp(-x))

def sigmoid_p(x):
  return sigmoid(x) * (1 - sigmoid(x))

X = np.linspace(-5, 5, 100)

plt.plot(X, sigmoid(X), c="b") # sigmoid in blue
plt.plot(X, sigmoid_p(X), c="r") # sigmoid_p in red

# train

def train():
  #random int of weights
  w1 = np.random.randn()
  w2 = np.random.randn()
  b = np.random.randn()

  iterations = 10000
  learning_rate = 0.2
  costs = [] # store costs during training, analyze

  for i in range(iterations):
    # random point
    ri = np.random.randint(len(data))
    point = data[ri]

    z = point[0] * w1 + point[1] * w2 + b
    pred = sigmoid(z) # network prediction

    target = point[2]

    # cost for current random point
    cost = np.square(pred - target)

    # print the cost over all data points every 1k iterations
    if i % 100 == 0:
      c = 0
      for j in range(len(data)):
        p = data[j]
        p_pred = sigmoid(w1 * p[0] + w2 * p[1] + b)
        c += np.square(p_pred - p[2])
      costs.append(c)

    dcost_dpred = 2 * (pred -target)
    dpred_dz = sigmoid_p(z)

    dz_dw1 = point[0]
    dz_dw2 = point[1]
    dz_db = 1

    dcost_dz = dcost_dpred * dpred_dz

    dcost_dw1 = dcost_dz * dz_dw1
    dcost_dw2 = dcost_dz * dz_dw2
    dcost_db = dcost_dz * dz_db

    w1 = w1 - learning_rate * dcost_dw1
    w2 = w2 - learning_rate * dcost_dw2
    b = b - learning_rate * dcost_db

  return costs, w1, w2, b

costs, w1, w2, b = train()

fig = plt.plot(costs)

b

# predict mystery planet result

z = w1 * mystery_planet[0] + w2 * mystery_planet[1] + b
pred = sigmoid(z)

print(pred)
if pred < 0.5:
  print("Gas Giant")
else:
  print("Terrestrial Planet")

def planet(planetary_radius, orbital_period):
  z = planetary_radius * w1 + orbital_period * w2 + b
  pred = sigmoid(z)
  print(pred)
  if pred < 0.5:
    print("The exoplanet is a gas giant")
  else:
    print("The exoplanet is a terrestrial planet")

pr = input("What is the planet's radius? ")
op = input("What is the planet's orbital period? ")
planet(float(pr), float(op))



